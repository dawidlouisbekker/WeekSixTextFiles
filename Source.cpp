#include <iostream>
#include <fstream>
#include <memory>
#include <thread>
#include <chrono>
#include <iomanip>
#include <typeinfo>
#include <bitset>
#include <grpcpp/grpcpp.h> //always include this if you want to use grpc. Ask ChatGPT how to install grpc through vcpkg and integrate the installs with visual studio
#include "student.grpc.pb.h" //this is generated by protoc and needed by both client and server to override the functions defined in .proto
#include <vector>

//Server imports if you want to split it up
using grpc::Server;
using grpc::ServerBuilder;
using grpc::ServerContext;
using grpc::ServerWriter;

//student imports if you want to split it up
using grpc::Status;
using grpc::Channel;
using grpc::ClientContext;
using grpc::ClientReader;

using namespace std;

bool ServerStarted = false;

#include <iostream>
#include <string>
#include <typeinfo>
#include <limits>

template <typename Var>/////////From my project. Took lots of debugging and figuring out lol
std::string CheckInput(Var& Input, int Options = 0, int MaxLength = -1, float MinValue = -1.0f, float MaxValue = -1.0f) {

    std::string line;
    bool IsValid = false;

    while (!IsValid) {
        IsValid = true;
        std::getline(std::cin, line);

        try {
            float value = std::stof(line);
            if (MaxValue > 0 && value > MaxValue) {
                std::cout << "Maximum number is " << MaxValue << ". Please try again: ";
                IsValid = false;
                continue;
            }
            if (value < MinValue) {
                std::cout << "Minimum number is " << MinValue << ". Please try again: ";
                IsValid = false;
                continue;
            }
        }
        catch (...) {
            if (typeid(Input) == typeid(int) || typeid(Input) == typeid(double)) {
                std::cout << "Invalid number. Please try again: ";
                IsValid = false;
                continue;
            }
        }

        if (Options == 0) {
            if (typeid(Input) == typeid(int)) {
                for (char ch : line) {
                    if (ch < '0' || ch > '9') {
                        std::cout << "You did not enter a valid integer. Please try again: ";
                        IsValid = false;
                        break;
                    }
                }
            }
            else if (typeid(Input) == typeid(std::string)) {
                for (char ch : line) {
                    if (!std::isalpha(ch)) {
                        std::cout << "You did not enter a valid string (A-Z and a-z only). Please try again: ";
                        IsValid = false;
                        break;
                    }
                }
            }
        }

        if (!IsValid) {
            std::cout << "Enter: ";
        }
    }
    return line;
}


void printBinary(const std::string& input) {
    for (char c : input) {
        // Convert each character to an 8-bit binary representation
        std::bitset<8> binary(c);
        std::cout << binary << ' ';
    }
    std::cout << std::endl;
}

struct Student {
    int id = -1;
    string name = "";
    vector<float> grades = {};
    Student(int i, string n, vector<float> g) : id(i), name(n), grades(g) {}
    bool operator==(const Student& student) const {
        return id== student.id && name == student.name;
    }
};

ofstream OpenFile() {
    try {
        ofstream file("records.txt", ios::app);
        if (!file.is_open()) {
            cout << endl << "Error opening file" << endl;
        }
        return file;
    }
    catch (const ios_base::failure& e) {
        cerr << endl << e.what() << endl;
    }
    
}

void SearchFile() {

}

class StudentServiceImpl final : public StudentService::Service {
public:

    StudentServiceImpl() {
        PopulateStudentVector();
    }

private:
    vector<Student> Students;

    void WriteStructsToTextFile(){
        ofstream file("records.txt");
        for (const Student& student : Students) {
            for (int i = 0; i < student.grades.size(); i++) {
                file << "id: " << student.id << ' ';
                file << "name: " << student.name << ' ';
                file << "grade: " << fixed << setprecision(2) << student.grades[i] << endl;
            }
        }
        file << "!";
        file.close();
    }

    void PopulateStudentVector() {
        ifstream file("records.txt");
        string line;
        int id;
        string name;
        float grade;

        if (file.is_open()) {
            while (!file.eof()) {
                bool found = false;
                file >> line;
                if (line[0] != '!') {
                    file >> id;
                    file >> line;
                    file >> name;
                    file >> line;
                    file >> grade;
                    for (Student& student : Students) { //////////took very long to figure out I need &. What I would do instead of ITMTB lol.
                        if (id == student.id && name.empty() == false) {
                            student.grades.push_back(grade);

                            found = true;
                            break;
                        }
                    }
                    if (!found && name.empty() == false) {
                        vector<float> SingleStudentGrades;
                        SingleStudentGrades.push_back(grade);
                        Students.emplace_back(id, name, SingleStudentGrades);
                    }
                }

                line = "!";
            }
            file.close();
        }
        else {
            cout << "Something went wrong with opening the Text File. Creating text file and trying again. It might not save the data" << endl;
            ofstream CreateFile("records.txt", ios::app);
            CreateFile.close();

        }
        file.open("records.txt");
        if (file.is_open()) {
            while (!file.eof()) {
                bool found = false;
                file >> line;
                if (line[0] != '!') {
                    file >> id;
                    file >> line;
                    file >> name;
                    file >> line;
                    file >> grade;
                    for (Student& student : Students) { //////////took very long to figure out I need &. What I would do instead of ITMTB lol.
                        if (id == student.id && name.empty() == false) {
                            student.grades.push_back(grade);

                            found = true;
                            break;
                        }
                    }
                    if (!found && name.empty() == false) {
                        vector<float> SingleStudentGrades;
                        SingleStudentGrades.push_back(grade);
                        Students.emplace_back(id, name, SingleStudentGrades);
                    }
                }

                line = "!";
            }
            file.close();
        }
        else {
            cout << "I don't know. Try add a records.txt in the same folder as this." << endl;


        }
        file.close();
       
    }

    Status DeleteStudent(ServerContext* context, const StudentID* request, ResponseMessage* response) override {
        cout << endl << "Recieved rpc from: " << context->peer() << endl;
        int id = request->id();
        bool found = false;
        string message;
        for (Student& student : Students) { //////////took very long to figure out I need &. What I would do instead of ITMTB lol.
            if (id == student.id) {
                string name = student.name;
                found =  true;

                Students.erase(remove(Students.begin(), Students.end(), student), Students.end());
                response->set_response(name + " has been removed successfully");
                break;
            }
        }
 
        cout << endl;
        if (!found) {
            message = "No body has the ID of " + to_string(id);
            response->set_response(message);
            
        }
        WriteStructsToTextFile();
        return Status::OK;
    }

    Status SearchStudent(ServerContext* context, const StudentID* request, ServerWriter<StudentDetails>* writer) override {
        cout << endl << "Recieved rpc from: " << context->peer() << endl;
        fstream file("records.txt");
        
        StudentDetails reply;
        string line;
        int id;
        string name;
        float grade;
        
        if (file.is_open()) {
            bool found = false;
            while (!file.eof()) {
                file >> line;
              //  cout << line;
                file >> id;
              //  cout << id;
                file >> line;
                file >> name;
             //   cout << name;
                file >> line;
                file >> grade;
             //   cout << grade;
                if (id == request->id()) {
                    if (name[0] != '!') {
                        reply.set_name(name);
                        reply.set_grade(grade);
                        writer->Write(reply);
                    }

                }


            }
            if (found == false) {
                reply.set_id(0);
                reply.set_name("There was no student found with the ID:" + to_string(request->id()));
                reply.set_grade(0);
            }

        }
        else {
            cout << "   Server: Something went wrong with opening the Text File" << endl;

        }
        
        file.close();
        return Status::OK;
    }

	Status SendStudentMarks(ServerContext* context, const StudentDetails* request, ResponseMessage* reply) override {
        cout << endl << "Recieved rpc from: " << context->peer() << endl;
        bool found = false;
        int id = request->id();
		std::string name = request->name();
      //  printBinary(name);
		float grade = request->grade();
        for (Student& student : Students) { //////////took very long to figure out I need &. What I would do instead of ITMTB lol.
           // printBinary(student.name);
            if (id == student.id) {
                found = true;
                if (student.name == name) { 
                    student.grades.push_back(grade);
                    stringstream Stream;
                    Stream << fixed << setprecision(2) << grade;
                    reply->set_response("Received marks for student: " + name + " with grade: " + Stream.str());
                }
                else {
                    reply->set_response("$/Student with that ID already exists. They require a unique ID. ID " + to_string(id) + " is " + student.name);
                }


                
                break;
            }
        }
        if (found == false) {
            vector<float> SingleStudentGrades;
            SingleStudentGrades.push_back(grade);
            Students.emplace_back(id, name, SingleStudentGrades);
            stringstream Stream;
            Stream << fixed << setprecision(2) << grade;
            reply->set_response("Received marks for student: " + name + " with grade: " + Stream.str());
        }
        
        WriteStructsToTextFile();
        


		return Status::OK;
	}

    Status DisplayAllStudents(ServerContext* context, const ResponseMessage* reply, ServerWriter<StudentDetails>* writer) override {
        cout << endl << "Recieved rpc from: " << context->peer() << endl;
        ifstream file("records.txt");
        string line;
        StudentDetails message;

        int id;
        string name;
        float grade;

        if (file.is_open()) {
            while (!file.eof()) {
                
                file >> line;
               // cout << line << "." <<endl;
                if (line == "") {
                    message.set_id(-1);
                    message.set_name("");
                    message.set_grade(0);
                    writer->Write(message);
                }
                else {
                    if (line[0] != '!') {
                        file >> id;
                        file >> line;
                        file >> name;
                        file >> line;
                        file >> grade;
                        message.set_id(id);
                        message.set_name(name);
                        message.set_grade(grade);
                        writer->Write(message);
                    }
                }
                
                line = "!";

            } 
            file.close();
            return Status::OK;
        }
        else {

            cout << "   Server: Something went wrong with opening the Text File" << endl;
            file.close();
            return Status::CANCELLED;
        }
        file.close();

        return Status::OK;
    }
};

void RunServer() {
    std::string server_address("127.0.0.1:50051");
    auto service = std::make_unique<StudentServiceImpl>();

    ServerBuilder builder;
    builder.AddListeningPort(server_address, grpc::InsecureServerCredentials());
    builder.RegisterService(service.get());
    std::unique_ptr<Server> server(builder.BuildAndStart());
    std::cout << "Server listening on " << server_address << std::endl;
    ServerStarted = true;
    server->Wait();
}
////////////////////////////////////////////////////////////////// GRPC client
class StudentServiceClient {
public:


    StudentServiceClient(std::shared_ptr<Channel> channel)
        : stub_(StudentService::NewStub(channel)) {}


    Status SearchStudent(int id) {
        ClientContext context;
        StudentID request;
      
        StudentDetails student_details;
        request.set_id(id);
        unique_ptr<ClientReader<StudentDetails>> reader(stub_->SearchStudent(&context, request));
        while (reader->Read(&student_details)) {
            cout << " Name: " << student_details.name() << ", Grade : " << student_details.grade() << endl;
        }
        return Status::OK;
    }

    void SendStudentMarks(int id, const std::string name, float grade) {
        StudentDetails request;
        request.set_id(id);
        request.set_name(name);
        request.set_grade(grade);

        ResponseMessage reply;
        ClientContext context;

        Status status = stub_->SendStudentMarks(&context, request, &reply);
        cout << reply.response() << endl;

        if (!status.ok()) {
            std::cerr << "gRPC failed: " << status.error_message() << std::endl;
        }
    }

    Status DeleteStudent(int id) {
        ClientContext context;
        StudentID request;
        ResponseMessage response;

        request.set_id(id);
        Status status = stub_->DeleteStudent(&context, request, &response);

        cout << response.response() << endl;

        return Status::OK;

    }
    /*  string Response;
while (reader->Read(&student_details)) {

    bool found = false;
    for (Student &student : Students) { //////////took very long to figure out I need &. What I would do instead of ITMTB lol.
        if (student_details.id() == student.id) {
            student.grades.push_back(student_details.grade());
            found = true;
            break;
        }
    }
    if (!found) {
        vector<float> SingleStudentGrades;
        SingleStudentGrades.push_back(student_details.grade());
        Students.emplace_back(student_details.id(), student_details.name(), SingleStudentGrades);
    }

}*/
    Status DisplayAllStudents() {
        const ResponseMessage request;
        ClientContext context;
        unique_ptr<ClientReader<StudentDetails>> reader(stub_->DisplayAllStudents(&context, request));
        StudentDetails student_details;
        while (reader->Read(&student_details)) {
            if (student_details.id() == -1) {
                cout << "There are currently no students in the records." << endl;
            }
            else {
                cout << "ID: " << student_details.id() << ", Name: " << student_details.name() << ", Grade: " << student_details.grade() << endl;
            }

        }


        return Status::OK;
    }

private:
    std::unique_ptr<StudentService::Stub> stub_;
   // vector<Student> Students;


};

string CheckInput() {
    string input;
    getline(cin, input);
    if (input == "exit") {
        exit(0);
    }
    return input;
}


void static DisplayMenu(StudentServiceClient* client) {
    int choice;
    int id;
    string name;
    float grade;
    do {
        cout << endl;
        cout << "options\n";
        cout << "1. Add Student (enter 1)\n";
        cout << "2. Display All Students (enter 2)\n";
        cout << "3. Search students record by ID (enter 3)\n";
        cout << "4. Delete student records by entering their ID (enter 4)\n";
        cout << "Enter 0 to exit\n";
        cout << endl;

        cout << "Enter choice: ";
        choice = stoi(CheckInput(choice, 0, -1, 0, 4));
        switch (choice) {
        case 1:
            cout << endl;
            cout << "Add new student (only enter first name):" << endl;
            cout << " Enter id:";
            id = stoi(CheckInput(choice, 0, -1, 1));
            cout << " Enter name:";
            name = CheckInput(name);
            cout << " Enter grade:";
            grade = stof(CheckInput(grade,0, -1, 0, 100));
            cout << endl;
            client->SendStudentMarks(id, name, grade);
            break;
        case 2:
            client->DisplayAllStudents();
            break;
        case 3:
            cout << "Enter ID:";
            choice = stoi(CheckInput(choice));
            cout << endl;
            client->SearchStudent(choice);
            break;
        case 4:
            cout << "Enter ID: ";
            choice = stoi(CheckInput(choice));
            cout << endl;
            client->DeleteStudent(choice);
            break;
        case 0:
            exit(0);
        default:
            std::cout << "Invalid choice, please try again.\n";
        }
    } while (choice != 0);
}

int main() {
    thread ServerThread(RunServer);

    StudentServiceClient client(grpc::CreateChannel("127.0.0.1:50051", grpc::InsecureChannelCredentials()));
    while (true) {
        if (ServerStarted) {
            DisplayMenu(&client);
        }
        
    }

}
